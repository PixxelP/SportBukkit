From 4e821a2afc5f6201754a1437764d9f5849c8def4 Mon Sep 17 00:00:00 2001
From: Jedediah Smith <jedediah@silencegreys.com>
Date: Mon, 10 Oct 2016 04:53:27 -0400
Subject: [PATCH] Block images


diff --git a/src/main/java/net/minecraft/server/BlockPosition.java b/src/main/java/net/minecraft/server/BlockPosition.java
index b241977..226db07 100644
--- a/src/main/java/net/minecraft/server/BlockPosition.java
+++ b/src/main/java/net/minecraft/server/BlockPosition.java
@@ -8,8 +8,224 @@ import javax.annotation.concurrent.Immutable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
+// SportBukkit start - implement Vec3
+import org.bukkit.util.ImVector;
+import org.bukkit.util.MutableVec3;
+import org.bukkit.util.Vec3;
+import org.bukkit.util.Vec3Utils;
+
 @Immutable
-public class BlockPosition extends BaseBlockPosition {
+public class BlockPosition extends BaseBlockPosition implements Vec3 {
+
+    public static BlockPosition of(Vec3 that) {
+        return that instanceof BlockPosition
+               ? (BlockPosition) that
+               : new BlockPosition(that.blockX(), that.blockY(), that.blockZ());
+    }
+
+    public static BlockPosition copyOf(Vec3 that) {
+        return that instanceof BlockPosition && !that.isMutable()
+               ? (BlockPosition) that
+               : new BlockPosition(that.blockX(), that.blockY(), that.blockZ());
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        return Vec3Utils.equals(this, obj);
+    }
+
+    @Override
+    public int hashCode() {
+        return Vec3Utils.blockHashCode(this);
+    }
+
+    @Override
+    public Vec3 copy() {
+        return this;
+    }
+
+    @Override
+    public Vec3 blockVector() {
+        return this;
+    }
+
+    @Override
+    public boolean isMutable() {
+        return false;
+    }
+
+    @Override
+    public boolean isFine() {
+        return false;
+    }
+
+    @Override
+    public boolean isCoarse() {
+        return true;
+    }
+
+    @Override
+    public double realElement(int i) {
+        return blockElement(i);
+    }
+
+    @Override
+    public double realX() {
+        return getX();
+    }
+
+    @Override
+    public double realY() {
+        return getY();
+    }
+
+    @Override
+    public double realZ() {
+        return getZ();
+    }
+
+    @Override
+    public boolean isZero() {
+        return getX() == 0 && getY() == 0 && getZ() == 0;
+    }
+
+    @Override
+    public int blockElement(int i) {
+        switch(i) {
+            case 0: return getX();
+            case 1: return getY();
+            case 2: return getZ();
+        }
+        throw new IndexOutOfBoundsException();
+    }
+
+    @Override
+    public int blockX() {
+        return getX();
+    }
+
+    @Override
+    public int blockY() {
+        return getY();
+    }
+
+    @Override
+    public int blockZ() {
+        return getZ();
+    }
+
+    @Override
+    public boolean isBlockZero() {
+        return isZero();
+    }
+
+    @Override
+    public boolean isLess(Vec3 v) {
+        return getX() < v.blockX() && getY() < v.blockY() && getZ() < v.blockZ();
+    }
+
+    @Override
+    public boolean isLessOrEqual(Vec3 v) {
+        return getX() <= v.blockX() && getY() <= v.blockY() && getZ() <= v.blockZ();
+    }
+
+    @Override
+    public boolean isGreater(Vec3 v) {
+        return getX() > v.blockX() && getY() > v.blockY() && getZ() > v.blockZ();
+    }
+
+    @Override
+    public boolean isGreaterOrEqual(Vec3 v) {
+        return getX() >= v.blockX() && getY() >= v.blockY() && getZ() >= v.blockZ();
+    }
+
+    @Override
+    public BlockPosition negate() {
+        return isZero() ? this : new BlockPosition(-getX(), -getY(), -getZ());
+    }
+
+    @Override
+    public Vec3 plus(int x, int y, int z) {
+        return x == 0 && y == 0 && z == 0 ? this
+                                          : new BlockPosition(getX() + x, getY() + y, getZ() + z);
+    }
+
+    @Override
+    public ImVector plus(double x, double y, double z) {
+        return ImVector.of(realX() + x, realY() + y, realZ() + z);
+    }
+
+    @Override
+    public Vec3 plus(Vec3 v) {
+        if(v.isFine()) {
+            return ImVector.of(realX() + v.realX(),
+                               realY() + v.realY(),
+                               realZ() + v.realZ());
+        }
+
+        if(isZero()) return copyOf(v);
+        if(v.isZero()) return this;
+
+        return new BlockPosition(getX() + v.blockX(),
+                                 getY() + v.blockY(),
+                                 getZ() + v.blockZ());
+    }
+
+    @Override
+    public Vec3 minus(Vec3 v) {
+        if(v.isFine()) {
+            return ImVector.of(realX() - v.realX(),
+                               realY() - v.realY(),
+                               realZ() - v.realZ());
+        }
+
+        if(isZero()) return copyOf(v).negate();
+        if(v.isZero()) return this;
+
+        return new BlockPosition(getX() - v.blockX(),
+                                 getY() - v.blockY(),
+                                 getZ() - v.blockZ());
+    }
+
+    @Override
+    public BlockPosition times(int n) {
+        if(n == 0) return ZERO;
+        if(isZero()) return this;
+
+        return new BlockPosition(getX() * n,
+                                 getY() * n,
+                                 getZ() * n);
+    }
+
+    @Override
+    public ImVector times(double n) {
+        return ImVector.of(realX() * n, realY() * n, realZ() * n);
+    }
+
+    @Override
+    public Vec3 times(Vec3 v) {
+        if(v.isFine()) {
+            return ImVector.of(realX() * v.realX(),
+                               realY() * v.realY(),
+                               realZ() * v.realZ());
+        }
+
+        if(isZero()) return this;
+        if(v.isZero()) return ZERO;
+
+        return new BlockPosition(getX() * v.blockX(),
+                                 getY() * v.blockY(),
+                                 getZ() * v.blockZ());
+    }
+
+    @Override
+    public double dot(Vec3 v) {
+        return realX() * v.realX() +
+               realY() * v.realY() +
+               realZ() * v.realZ();
+    }
+
+    // SportBukkit end
 
     private static final Logger b = LogManager.getLogger();
     public static final BlockPosition ZERO = new BlockPosition(0, 0, 0);
@@ -321,7 +537,95 @@ public class BlockPosition extends BaseBlockPosition {
         }
     }
 
-    public static class MutableBlockPosition extends BlockPosition {
+    // SportBukkit start - implement MutableVec3
+    public static class MutableBlockPosition extends BlockPosition implements MutableVec3 {
+
+        @Override
+        public Vec3 copy() {
+            return new BlockPosition(this);
+        }
+
+        @Override
+        public MutableBlockPosition setX(int x) {
+            this.b = x;
+            return this;
+        }
+
+        @Override
+        public MutableBlockPosition setY(int y) {
+            this.c = y;
+            return this;
+        }
+
+        @Override
+        public MutableBlockPosition setZ(int z) {
+            this.d = z;
+            return this;
+        }
+
+        @Override
+        public MutableBlockPosition setX(double x) {
+            return setX(MathHelper.floor(x));
+        }
+
+        @Override
+        public MutableBlockPosition setY(double y) {
+            return setY(MathHelper.floor(y));
+        }
+
+        @Override
+        public MutableBlockPosition setZ(double z) {
+            return setZ(MathHelper.floor(z));
+        }
+
+        @Override
+        public MutableBlockPosition setZero() {
+            return set(0, 0, 0);
+        }
+
+        @Override
+        public MutableBlockPosition set(int x, int y, int z) {
+            this.b = x;
+            this.c = y;
+            this.d = z;
+            return this;
+        }
+
+        @Override
+        public MutableBlockPosition set(double x, double y, double z) {
+            return set(MathHelper.floor(x),
+                       MathHelper.floor(y),
+                       MathHelper.floor(z));
+        }
+
+        @Override
+        public MutableBlockPosition set(Vec3 v) {
+            return set(v.blockX(),
+                       v.blockY(),
+                       v.blockZ());
+        }
+
+        @Override
+        public MutableVec3 add(double x, double y, double z) {
+            return set(realX() + x,
+                       realY() + y,
+                       realZ() + z);
+        }
+
+        @Override
+        public MutableVec3 add(int x, int y, int z) {
+            return set(blockX() + x,
+                       blockY() + y,
+                       blockZ() + z);
+        }
+
+        @Override
+        public MutableVec3 add(Vec3 v) {
+            return v.isFine() ? add(v.realX(), v.realY(), v.realZ())
+                              : add(v.blockX(), v.blockY(), v.blockZ());
+        }
+
+        // SportBukkit end
 
         protected int b;
         protected int c;
diff --git a/src/main/java/org/bukkit/CraftBukkitRuntime.java b/src/main/java/org/bukkit/CraftBukkitRuntime.java
index 531d9f6..8639825 100644
--- a/src/main/java/org/bukkit/CraftBukkitRuntime.java
+++ b/src/main/java/org/bukkit/CraftBukkitRuntime.java
@@ -1,12 +1,18 @@
 package org.bukkit;
 
 import net.minecraft.server.DispenserRegistry;
+import org.bukkit.block.BlockIteratorFactory;
+import org.bukkit.block.BlockTransformFactory;
 import org.bukkit.block.RegionFactory;
+import org.bukkit.craftbukkit.block.CraftBlockIteratorFactory;
+import org.bukkit.craftbukkit.block.CraftBlockTransformFactory;
 import org.bukkit.craftbukkit.block.CraftRegionFactory;
 import org.bukkit.craftbukkit.inventory.CraftItemFactory;
+import org.bukkit.craftbukkit.material.CraftBlockOrienter;
 import org.bukkit.craftbukkit.potion.CraftPotionEffectRegistry;
 import org.bukkit.craftbukkit.potion.CraftPotionBrewRegistry;
 import org.bukkit.craftbukkit.registry.CraftKey;
+import org.bukkit.material.BlockOrienter;
 import org.bukkit.potion.PotionEffectRegistry;
 import org.bukkit.potion.PotionBrewRegistry;
 import org.bukkit.registry.Key;
@@ -26,6 +32,11 @@ public class CraftBukkitRuntime implements BukkitRuntime {
         }
     }
 
+    private final CraftBlockIteratorFactory blockIterators = new CraftBlockIteratorFactory();
+    private final CraftBlockTransformFactory blockTransforms = new CraftBlockTransformFactory();
+    private final CraftBlockOrienter blockOrienter = new CraftBlockOrienter();
+    private final CraftRegionFactory regions = new CraftRegionFactory();
+
     private final PotionBrewRegistry potionBrewRegistry = new CraftPotionBrewRegistry();
     private final PotionEffectRegistry potionEffectRegistry = new CraftPotionEffectRegistry();
 
@@ -44,13 +55,28 @@ public class CraftBukkitRuntime implements BukkitRuntime {
     }
 
     @Override
-    public CraftItemFactory getItemFactory() {
-        return CraftItemFactory.instance();
+    public BlockIteratorFactory blockIterators() {
+        return blockIterators;
+    }
+
+    @Override
+    public BlockTransformFactory blockTransforms() {
+        return blockTransforms;
+    }
+
+    @Override
+    public BlockOrienter blockOrienter() {
+        return blockOrienter;
     }
 
     @Override
-    public RegionFactory getRegionFactory() {
-        return CraftRegionFactory.instance();
+    public RegionFactory regions() {
+        return regions;
+    }
+
+    @Override
+    public CraftItemFactory getItemFactory() {
+        return CraftItemFactory.instance();
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index a344ef4..35960c5 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -37,6 +37,7 @@ import org.bukkit.Warning.WarningState;
 import org.bukkit.World;
 import org.bukkit.World.Environment;
 import org.bukkit.WorldCreator;
+import org.bukkit.block.RegionFactory;
 import org.bukkit.boss.BarColor;
 import org.bukkit.boss.BarFlag;
 import org.bukkit.boss.BarStyle;
@@ -51,6 +52,7 @@ import org.bukkit.configuration.ConfigurationSection;
 import org.bukkit.configuration.file.YamlConfiguration;
 import org.bukkit.configuration.serialization.ConfigurationSerialization;
 import org.bukkit.conversations.Conversable;
+import org.bukkit.craftbukkit.block.CraftRegionFactory;
 import org.bukkit.craftbukkit.boss.CraftBossBar;
 import org.bukkit.craftbukkit.command.VanillaCommandWrapper;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
@@ -1725,11 +1727,6 @@ public final class CraftServer extends CraftBukkitRuntime implements Server {
     }
 
     @Override
-    public CraftItemFactory getItemFactory() {
-        return CraftItemFactory.instance();
-    }
-
-    @Override
     public CraftScoreboardManager getScoreboardManager() {
         return scoreboardManager;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index c03c239..b8e4467 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -30,15 +30,19 @@ import org.bukkit.WorldBorder;
 import org.bukkit.block.Biome;
 import org.bukkit.block.Block;
 import org.bukkit.block.BlockFace;
+import org.bukkit.block.BlockImage;
+import org.bukkit.block.BlockRegion;
 import org.bukkit.block.BlockState;
+import org.bukkit.block.BlockTransform;
+import org.bukkit.util.Vec3;
 import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.craftbukkit.block.CraftBlockImage;
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.entity.*;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.metadata.BlockMetadataStore;
 import org.bukkit.craftbukkit.potion.CraftPotionUtil;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.entity.*;
 import org.bukkit.entity.Entity;
 import org.bukkit.entity.minecart.CommandMinecart;
@@ -1546,4 +1550,24 @@ public class CraftWorld implements World {
             cps.unload(chunk);
         }
     }
+
+    @Override
+    public BlockImage copyBlocks(BlockRegion region, boolean includeAir, boolean clearSource) {
+        return new CraftBlockImage(this, region, includeAir, clearSource);
+    }
+
+    @Override
+    public int pasteBlocks(BlockImage image, BlockTransform transform) {
+        return ((CraftBlockImage) image).write(this, transform);
+    }
+
+    @Override
+    public int pasteBlocks(BlockImage image, Vec3 offset) {
+        return pasteBlocks(image, Bukkit.blockTransforms().translation(offset));
+    }
+
+    @Override
+    public int pasteBlocks(BlockImage image) {
+        return pasteBlocks(image, Bukkit.blockTransforms().identity());
+    }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/block/BakedRegion.java b/src/main/java/org/bukkit/craftbukkit/block/BakedRegion.java
new file mode 100644
index 0000000..1c6a595
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/block/BakedRegion.java
@@ -0,0 +1,34 @@
+package org.bukkit.craftbukkit.block;
+
+import java.util.AbstractSet;
+import java.util.Set;
+
+import com.google.common.collect.ImmutableSet;
+import org.bukkit.Bukkit;
+import org.bukkit.util.Vec3;
+import org.bukkit.block.BlockPositionIterator;
+import org.bukkit.block.BlockRegion;
+
+public class BakedRegion extends AbstractSet<Vec3> implements BlockRegion {
+
+    private final Set<Vec3> positions;
+
+    public BakedRegion(BlockRegion raw) {
+        positions = ImmutableSet.<Vec3>builder().addAll(raw).build();
+    }
+
+    @Override
+    public int size() {
+        return positions.size();
+    }
+
+    @Override
+    public boolean contains(Vec3 position) {
+        return positions.contains(position);
+    }
+
+    @Override
+    public BlockPositionIterator iterator() {
+        return Bukkit.blockIterators().iterator(positions.iterator());
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/BlockPositionIteratorAdapter.java b/src/main/java/org/bukkit/craftbukkit/block/BlockPositionIteratorAdapter.java
new file mode 100644
index 0000000..66e93b6
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/block/BlockPositionIteratorAdapter.java
@@ -0,0 +1,37 @@
+package org.bukkit.craftbukkit.block;
+
+import java.util.Iterator;
+
+import net.minecraft.server.BlockPosition;
+import org.bukkit.util.Vec3;
+import org.bukkit.block.BlockPositionIterator;
+
+public class BlockPositionIteratorAdapter extends BlockPosition.MutableBlockPosition implements BlockPositionIterator {
+
+    private final Iterator<? extends Vec3> iterator;
+
+    private BlockPositionIteratorAdapter(Iterator<? extends Vec3> iterator) {
+        this.iterator = iterator;
+    }
+
+    public static BlockPositionIterator of(Iterator<? extends Vec3> iterator) {
+        return iterator instanceof BlockPositionIterator
+               ? (BlockPositionIterator) iterator
+               : new BlockPositionIteratorAdapter(iterator);
+    }
+
+    @Override
+    public boolean hasNext() {
+        return iterator.hasNext();
+    }
+
+    @Override
+    public Vec3 next() {
+        return set(iterator.next());
+    }
+
+    @Override
+    public void remove() {
+        iterator.remove();
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CachingBlockPositionIterator.java b/src/main/java/org/bukkit/craftbukkit/block/CachingBlockPositionIterator.java
new file mode 100644
index 0000000..a3a863a
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/block/CachingBlockPositionIterator.java
@@ -0,0 +1,46 @@
+package org.bukkit.craftbukkit.block;
+
+import com.google.common.collect.AbstractIterator;
+import net.minecraft.server.BlockPosition;
+import org.bukkit.util.Vec3;
+import org.bukkit.block.BlockPositionIterator;
+
+/**
+ * Works just like {@link AbstractIterator}
+ */
+public abstract class CachingBlockPositionIterator extends BlockPosition.MutableBlockPosition implements BlockPositionIterator {
+
+    private final InnerIterator inner = new InnerIterator();
+
+    protected abstract Vec3 computeNext();
+
+    protected Vec3 endOfData() {
+        return inner.end();
+    }
+
+    @Override
+    public final boolean hasNext() {
+        return inner.hasNext();
+    }
+
+    @Override
+    public final Vec3 next() {
+        return set(inner.next());
+    }
+
+    @Override
+    public void remove() {
+        throw new UnsupportedOperationException(getClass().getSimpleName() + " does not support removal");
+    }
+
+    private class InnerIterator extends AbstractIterator<Vec3> {
+        @Override
+        protected Vec3 computeNext() {
+            return CachingBlockPositionIterator.this.computeNext();
+        }
+
+        Vec3 end() {
+            return endOfData();
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockImage.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockImage.java
new file mode 100644
index 0000000..c509342
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockImage.java
@@ -0,0 +1,232 @@
+package org.bukkit.craftbukkit.block;
+
+import java.util.AbstractSet;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
+
+import com.google.common.collect.Iterables;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.NBTTagCompound;
+import net.minecraft.server.NextTickListEntry;
+import net.minecraft.server.StructureBoundingBox;
+import net.minecraft.server.TileEntity;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.block.BlockImage;
+import org.bukkit.block.BlockOrientation;
+import org.bukkit.block.BlockPositionIterator;
+import org.bukkit.block.BlockRegion;
+import org.bukkit.block.BlockTransform;
+import org.bukkit.util.Vec3;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.material.CraftBlockOrienter;
+
+/**
+ * Read/write algorithms are derived from the code for the /clone command,
+ * which can be found in {@link net.minecraft.server.CommandClone}.
+ */
+public class CraftBlockImage implements BlockImage {
+
+    static class BlockRecord extends BlockPosition {
+        final IBlockData blockData;
+        final NBTTagCompound tileEntityData;
+
+        public BlockRecord(Vec3 pos, IBlockData blockData, NBTTagCompound tileEntityData) {
+            super(pos.blockX(), pos.blockY(), pos.blockZ());
+            this.blockData = blockData;
+            this.tileEntityData = tileEntityData;
+        }
+
+        @Override
+        public BlockRecord clone() {
+            return new BlockRecord(this, blockData, tileEntityData);
+        }
+    }
+
+    private final UUID worldId;
+
+    private final Set<BlockPosition> blockSet = new HashSet<BlockPosition>();
+    private final List<BlockRecord> earlyBlocks = new ArrayList<BlockRecord>();
+    private final List<BlockRecord> tileEntities = new ArrayList<BlockRecord>();
+    private final List<BlockRecord> lateBlocks = new ArrayList<BlockRecord>();
+
+    private long tickTime;
+    private final List<NextTickListEntry> tickListEntries = new ArrayList<NextTickListEntry>();
+
+    public CraftBlockImage(CraftWorld world, BlockRegion region, boolean includeAir, boolean clearSource) {
+        this.worldId = world.getUID();
+        read(world, region, includeAir, clearSource);
+    }
+
+    private void read(CraftWorld craftWorld, BlockRegion region, boolean includeAir, boolean clearSource) {
+        final net.minecraft.server.WorldServer world = craftWorld.getHandle();
+        final BlockPosition.MutableBlockPosition mutablePosition = new BlockPosition.MutableBlockPosition();
+
+        for(Vec3 position : region) {
+            // Avoid creating any objects for air blocks, as long as the region
+            // iterator is spitting out NMS BlockPositions.
+            mutablePosition.set(position);
+            IBlockData blockData = world.getType(mutablePosition);
+
+            if(includeAir || blockData.getBlock() != Blocks.AIR) {
+                BlockRecord block;
+
+                TileEntity tileEntity = world.getTileEntity(mutablePosition);
+                if(tileEntity != null) {
+                    block = new BlockRecord(mutablePosition, blockData, new NBTTagCompound());
+                    tileEntity.save(block.tileEntityData);
+                    tileEntities.add(block);
+
+                    if(clearSource && tileEntity instanceof IInventory) {
+                        ((IInventory) tileEntity).l(); // Clear inventory
+                    }
+                } else {
+                    block = new BlockRecord(mutablePosition, blockData, null);
+                    if (!block.blockData.b() && // flammable
+                        !block.blockData.h()) { // full-sized
+                        lateBlocks.add(block);
+                    } else {
+                        earlyBlocks.add(block);
+                    }
+                }
+
+                blockSet.add(block);
+            }
+        }
+
+        if(clearSource) {
+            Iterable<BlockRecord> clearPositions = Iterables.concat(lateBlocks, tileEntities, earlyBlocks);
+
+            for(BlockRecord block : clearPositions) {
+                if(block.tileEntityData != null) {
+                    TileEntity tileEntity = world.getTileEntity(block);
+                    if(tileEntity instanceof IInventory) {
+                        ((IInventory) tileEntity).l();
+                    }
+                }
+                world.setTypeAndData(block, Blocks.BARRIER.getBlockData(), 2);
+            }
+
+            for(BlockRecord block : clearPositions) {
+                world.setTypeAndData(block, Blocks.AIR.getBlockData(), 3);
+            }
+        }
+
+        this.tickTime = world.getWorldData().getTime();
+
+        List<NextTickListEntry> ticks = world.a(new StructureBoundingBox(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE), false);
+        if(ticks != null) {
+            for(NextTickListEntry tick : ticks) {
+                if(blockSet.contains(tick.a)) {
+                    tickListEntries.add(tick);
+                }
+            }
+        }
+    }
+
+    public int write(CraftWorld craftWorld, BlockTransform transform) {
+        net.minecraft.server.WorldServer world = craftWorld.getHandle();
+
+        Iterable<BlockRecord> allBlocks = Iterables.concat(earlyBlocks, tileEntities, lateBlocks);
+        Iterable<BlockRecord> reversedBlocks = Iterables.concat(lateBlocks, tileEntities, earlyBlocks);
+
+        final BlockPosition.MutableBlockPosition mutablePosition = new BlockPosition.MutableBlockPosition();
+
+        // Fill the entire destination region with barrier blocks
+        for(BlockRecord block : reversedBlocks) {
+            mutablePosition.set(block);
+            transform.applyInPlace(mutablePosition);
+
+            // Clear any containers so they don't spill their contents
+            TileEntity tileEntity = world.getTileEntity(mutablePosition);
+            if (tileEntity instanceof IInventory) {
+                ((IInventory) tileEntity).l(); // Clear inventory
+            }
+
+            world.setTypeAndData(mutablePosition, Blocks.BARRIER.getBlockData(), 2);
+        }
+
+        int affectedBlocks = 0;
+        final CraftBlockOrienter orienter = (CraftBlockOrienter) Bukkit.blockOrienter();
+        final BlockOrientation orientation = transform.orientation();
+
+        for(BlockRecord block : allBlocks) {
+            mutablePosition.set(block);
+            transform.applyInPlace(mutablePosition);
+            if(world.setTypeAndData(mutablePosition, orienter.reorient(block.blockData, orientation), 2)) {
+                ++affectedBlocks;
+            }
+        }
+
+        for(BlockRecord block : tileEntities) {
+            mutablePosition.set(block);
+            transform.applyInPlace(mutablePosition);
+            TileEntity tileEntity = world.getTileEntity(mutablePosition);
+
+            if(block.tileEntityData != null && tileEntity != null) {
+                block.tileEntityData.setInt("x", mutablePosition.getX());
+                block.tileEntityData.setInt("y", mutablePosition.getY());
+                block.tileEntityData.setInt("z", mutablePosition.getZ());
+
+                tileEntity.a(block.tileEntityData);
+                tileEntity.update();
+            }
+
+            world.setTypeAndData(mutablePosition, orienter.reorient(block.blockData, orientation), 2);
+        }
+
+        for(BlockRecord block : reversedBlocks) {
+            mutablePosition.set(block);
+            transform.applyInPlace(mutablePosition);
+            world.update(mutablePosition, block.blockData.getBlock());
+        }
+
+        if(tickListEntries != null) {
+            for(NextTickListEntry entry : tickListEntries) {
+                mutablePosition.set(entry.a);
+                transform.applyInPlace(mutablePosition);
+                world.b(mutablePosition, entry.a(), (int) (entry.b - tickTime), entry.c);
+            }
+        }
+
+        return affectedBlocks;
+    }
+
+    @Override
+    public UUID getWorldId() {
+        return worldId;
+    }
+
+    @Override
+    public World getWorld() {
+        return Bukkit.getWorld(getWorldId());
+    }
+
+    @Override
+    public BlockRegion getRegion() {
+        return new Region();
+    }
+
+    class Region extends AbstractSet<Vec3> implements BlockRegion {
+        @Override
+        public int size() {
+            return blockSet.size();
+        }
+
+        @Override
+        public boolean contains(Vec3 position) {
+            return blockSet.contains(BlockPosition.of(position));
+        }
+
+        @Override
+        public BlockPositionIterator iterator() {
+            return Bukkit.blockIterators().iterator(blockSet.iterator());
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockIteratorFactory.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockIteratorFactory.java
new file mode 100644
index 0000000..f9faf0b
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockIteratorFactory.java
@@ -0,0 +1,15 @@
+package org.bukkit.craftbukkit.block;
+
+import java.util.Iterator;
+
+import org.bukkit.block.BlockIteratorFactory;
+import org.bukkit.util.Vec3;
+import org.bukkit.block.BlockPositionIterator;
+
+public class CraftBlockIteratorFactory implements BlockIteratorFactory {
+
+    @Override
+    public BlockPositionIterator iterator(Iterator<? extends Vec3> iterator) {
+        return BlockPositionIteratorAdapter.of(iterator);
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
index 97b75b7..c0f719a 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
@@ -1,13 +1,21 @@
 package org.bukkit.craftbukkit.block;
 
+import java.util.List;
+
 import net.minecraft.server.BlockPosition;
-import org.bukkit.Location;
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockFace;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.TileEntity;
+import org.bukkit.Bukkit;
 import org.bukkit.Chunk;
+import org.bukkit.Location;
 import org.bukkit.Material;
 import org.bukkit.World;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockOrientation;
+import org.bukkit.block.BlockReflection;
+import org.bukkit.block.BlockRotation;
 import org.bukkit.block.BlockState;
+import org.bukkit.block.BlockTransform;
 import org.bukkit.craftbukkit.CraftChunk;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
@@ -16,11 +24,6 @@ import org.bukkit.material.MaterialData;
 import org.bukkit.metadata.MetadataValue;
 import org.bukkit.plugin.Plugin;
 
-import java.util.List;
-import net.minecraft.server.EnumDirection;
-import net.minecraft.server.IBlockData;
-import net.minecraft.server.TileEntity;
-
 public class CraftBlockState implements BlockState {
     private final CraftWorld world;
     private final CraftChunk chunk;
@@ -307,4 +310,24 @@ public class CraftBlockState implements BlockState {
             throw new IllegalStateException("The blockState must be placed to call this method");
         }
     }
+
+    @Override
+    public void reflect(BlockReflection reflection) {
+        setMaterialData(Bukkit.blockOrienter().reflect(getMaterialData(), reflection));
+    }
+
+    @Override
+    public void rotate(BlockRotation rotation) {
+        setMaterialData(Bukkit.blockOrienter().rotate(getMaterialData(), rotation));
+    }
+
+    @Override
+    public void reorient(BlockOrientation orientation) {
+        setMaterialData(Bukkit.blockOrienter().reorient(getMaterialData(), orientation));
+    }
+
+    @Override
+    public void reorient(BlockTransform transform) {
+        setMaterialData(Bukkit.blockOrienter().reorient(getMaterialData(), transform));
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockTransform.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockTransform.java
new file mode 100644
index 0000000..29fb7c5
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockTransform.java
@@ -0,0 +1,206 @@
+package org.bukkit.craftbukkit.block;
+
+import java.util.Arrays;
+
+import net.minecraft.server.BlockPosition;
+import org.bukkit.block.BlockFace;
+import org.bukkit.block.BlockOrientation;
+import org.bukkit.block.BlockTransform;
+import org.bukkit.util.ImVector;
+import org.bukkit.util.MutableVec3;
+import org.bukkit.util.Vec3;
+
+/**
+ * Represents by a 4x4 matrix of the form:
+ *
+ *     [ xx  0   xz  xt ]
+ *     [ 0   1   0   yt ]
+ *     [ zx  0   zz  zt ]
+ *     [ 0   0   0   1  ]
+ *
+ * Where
+ *
+ *     xt, yt, zt are integers
+ *
+ * and
+ *
+ *     |  xx  xz  |
+ *     |          | = -1 or 1
+ *     |  zx  zz  |
+ *
+ * i.e. the determinant of the x-z minor 2x2 matrix is -1 or 1,
+ * which ensures that area is preserved in the x-z plane,
+ * though orientation may be inverted.
+ */
+public class CraftBlockTransform implements BlockTransform {
+
+    private final int xx, xz,
+                      zx, zz;
+    private final int xt, yt, zt;
+    private final int det;
+
+    public CraftBlockTransform(int xx, int xz, int zx, int zz, int xt, int yt, int zt) {
+        this.det = xx * zz - xz * zx;
+
+        if(det != -1 && det != 1) {
+            throw new IllegalArgumentException(
+                "Invalid block transform - coefficients do not preserve area: [ " + xx + " " + xz + " ], [ " + zx + " " + zz + " ]"
+            );
+        }
+
+        this.xx = xx; this.xz = xz;
+        this.zx = zx; this.zz = zz;
+
+        this.xt = xt; this.yt = yt; this.zt = zt;
+    }
+
+    @Override
+    public boolean isIdentity() {
+        return xx == 1 && xz == 0 &&
+               zx == 0 && zz == 1 &&
+               xt == 0 && yt == 0 && zt == 0;
+    }
+
+    public BlockPosition apply(BlockPosition v) {
+        final int x = v.blockX();
+        final int y = v.blockY();
+        final int z = v.blockZ();
+
+        return new BlockPosition(
+            x * xx + z * xz + xt,
+            y + yt,
+            x * zx + z * zz + zt
+        );
+    }
+
+    @Override
+    public Vec3 apply(Vec3 v) {
+        if(v instanceof BlockPosition) {
+            return apply((BlockPosition) v);
+        }
+
+        final double x = v.realX();
+        final double y = v.realY();
+        final double z = v.realZ();
+
+        return ImVector.of(
+            x * xx + z * xz + xt,
+            y + yt,
+            x * zx + z * zz + zt
+        );
+    }
+
+    public void applyInPlace(BlockPosition.MutableBlockPosition v) {
+        final int x = v.blockX();
+        final int y = v.blockY();
+        final int z = v.blockZ();
+
+        v.set(
+            x * xx + z * xz + xt,
+            y + yt,
+            x * zx + z * zz + zt
+        );
+    }
+
+    @Override
+    public void applyInPlace(MutableVec3 v) {
+        if(v instanceof BlockPosition.MutableBlockPosition) {
+            applyInPlace((BlockPosition.MutableBlockPosition) v);
+            return;
+        }
+
+        final double x = v.realX();
+        final double y = v.realY();
+        final double z = v.realZ();
+
+        v.set(
+            x * xx + z * xz + xt,
+            y + yt,
+            x * zx + z * zz + zt
+        );
+    }
+
+    @Override
+    public BlockFace apply(BlockFace face) {
+        return BlockFace.byDirection(apply(face.direction()));
+    }
+
+    @Override
+    public BlockTransform inverse() {
+        return new CraftBlockTransform(
+            xx, zx,
+            xz, zz,
+            - xx * xt - zx * zt,
+            - yt,
+            - xz * xt - zz * zt
+        );
+    }
+
+    @Override
+    public BlockTransform apply(BlockTransform other) {
+        if(other instanceof CraftBlockTransform) {
+            final CraftBlockTransform that = (CraftBlockTransform) other;
+            return new CraftBlockTransform(
+                this.xx * that.xx + this.xz * that.zx, this.xx * that.xz + this.xz * that.zz,
+                this.zx * that.xx + this.zz * that.zx, this.zx * that.xz + this.zz * that.zz,
+                this.xx * that.xt + this.xz * that.zt + this.xt,
+                this.yt + that.yt,
+                this.zx * that.xt + this.zz * that.zt + this.zt
+            );
+        }
+
+        return other.andThen(this);
+    }
+
+    @Override
+    public BlockTransform andThen(BlockTransform other) {
+        return other.apply(this);
+    }
+
+    @Override
+    public BlockOrientation orientation() {
+        final int x = xx + xz;
+        final int z = zx + zz;
+        int cw = 0;
+
+        if(x > 0) cw -= 2;
+        if(x * z > 0) cw -= 1;
+
+        if(det > 0) {
+            return BlockOrientation.of(false, cw - 1);
+        } else {
+            return BlockOrientation.of(true, cw);
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        // Identity transform is always 0
+        return isIdentity() ? 0 : Arrays.hashCode(new int[]{xx, xz, zx, zz, xt, yt, zt});
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if(this == obj) return true;
+
+        if(obj instanceof CraftBlockTransform) {
+            final CraftBlockTransform that = (CraftBlockTransform) obj;
+            return this.xx == that.xx &&
+                   this.xz == that.xz &&
+                   this.zx == that.zx &&
+                   this.zz == that.zz &&
+                   this.xt == that.xt &&
+                   this.yt == that.yt &&
+                   this.zt == that.zt;
+        }
+
+        return obj.equals(this);
+    }
+
+    @Override
+    public String toString() {
+        return BlockTransform.class.getSimpleName() +
+               "{orientation=" + orientation() +
+               " translation=(" + xt + ", " + yt + ", " + zt + ")}";
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockTransformFactory.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockTransformFactory.java
new file mode 100644
index 0000000..38d0c7c
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockTransformFactory.java
@@ -0,0 +1,99 @@
+package org.bukkit.craftbukkit.block;
+
+import java.util.Map;
+
+import com.google.common.collect.ImmutableMap;
+import org.bukkit.block.BlockOrientation;
+import org.bukkit.util.Vec3;
+import org.bukkit.block.BlockReflection;
+import org.bukkit.block.BlockRotation;
+import org.bukkit.block.BlockTransform;
+import org.bukkit.block.BlockTransformFactory;
+import org.bukkit.util.Axis;
+import org.bukkit.util.NumberConversions;
+
+public class CraftBlockTransformFactory implements BlockTransformFactory {
+
+    private static final int[] SIN = new int[] { 0, 1, 0, -1 };
+    private static final int[] COS = new int[] { 1, 0, -1, 0 };
+
+    private static final Map<Axis, CraftBlockTransform> AXES = ImmutableMap.of(
+        Axis.X, new CraftBlockTransform(
+            -1, 0,
+            0, 1,
+            0, 0, 0
+        ),
+        Axis.Z, new CraftBlockTransform(
+            1, 0,
+            0, -1,
+            0, 0, 0
+        )
+    );
+
+    public BlockTransform transform(int xx, int xz, int zx, int zz, int xt, int yt, int zt) {
+        return new CraftBlockTransform(xx, xz, zx, zz, xt, yt, zt);
+    }
+
+    @Override
+    public BlockTransform identity() {
+        return IdentityBlockTransform.instance();
+    }
+
+    @Override
+    public BlockTransform translation(int x, int y, int z) {
+        return new CraftBlockTransform(
+            1, 0,
+            0, 1,
+            x, y, z
+        );
+    }
+
+    @Override
+    public BlockTransform translation(Vec3 offset) {
+        return translation(offset.blockX(), offset.blockY(), offset.blockZ());
+    }
+
+    @Override
+    public BlockTransform reorientation(BlockOrientation orientation) {
+        // TODO: Optimize?
+        return reflection(orientation.reflection()).andThen(rotation(orientation.rotation()));
+    }
+
+    @Override
+    public BlockTransform reflection(Axis axis) {
+        final BlockTransform transform = AXES.get(axis);
+        if(transform == null) {
+            throw new IllegalArgumentException("Cannot reflect blocks in the " + axis + " axis");
+        }
+        return transform;
+    }
+
+    @Override
+    public BlockTransform reflection(BlockReflection reflection) {
+        switch(reflection) {
+            case FRONT_BACK: return AXES.get(Axis.X);
+            case LEFT_RIGHT: return AXES.get(Axis.Z);
+            default: return identity();
+        }
+    }
+
+    @Override
+    public BlockTransform rotationCCW(int turns) {
+        turns = NumberConversions.mod(turns, 4);
+        return new CraftBlockTransform(
+            COS[turns], -SIN[turns],
+            SIN[turns], COS[turns],
+            0, 0, 0
+        );
+    }
+
+    @Override
+    public BlockTransform rotationCW(int turns) {
+        return rotationCCW(-turns);
+    }
+
+    @Override
+    public BlockTransform rotation(BlockRotation rotation) {
+        return rotationCW(rotation.quarterTurnsCW());
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftRegionFactory.java b/src/main/java/org/bukkit/craftbukkit/block/CraftRegionFactory.java
new file mode 100644
index 0000000..b5fed9c
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftRegionFactory.java
@@ -0,0 +1,34 @@
+package org.bukkit.craftbukkit.block;
+
+import java.util.Set;
+
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.material.MaterialData;
+import org.bukkit.util.Vec3;
+import org.bukkit.block.BlockRegion;
+import org.bukkit.block.BlockTransform;
+import org.bukkit.block.RegionFactory;
+
+public class CraftRegionFactory implements RegionFactory {
+
+    @Override
+    public BlockRegion cuboid(Vec3 origin, Vec3 size) {
+        return new CuboidRegion(origin, origin.plus(size));
+    }
+
+    @Override
+    public BlockRegion transform(BlockRegion region, BlockTransform transform) {
+        return TransformedRegion.of(region, transform);
+    }
+
+    @Override
+    public BlockRegion translate(BlockRegion region, Vec3 offset) {
+        return transform(region, Bukkit.blockTransforms().translation(offset));
+    }
+
+    @Override
+    public BlockRegion mask(World world, BlockRegion region, Set<MaterialData> materials, boolean inverted) {
+        return new BakedRegion(new MaterialRegion(world, region, materials, inverted));
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CuboidRegion.java b/src/main/java/org/bukkit/craftbukkit/block/CuboidRegion.java
new file mode 100644
index 0000000..0e74bf3
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/block/CuboidRegion.java
@@ -0,0 +1,84 @@
+package org.bukkit.craftbukkit.block;
+
+import java.util.AbstractSet;
+import java.util.NoSuchElementException;
+
+import net.minecraft.server.BlockPosition;
+import org.bukkit.util.Vec3;
+import org.bukkit.block.BlockPositionIterator;
+import org.bukkit.block.BlockRegion;
+
+public class CuboidRegion extends AbstractSet<Vec3> implements BlockRegion {
+
+    private final BlockPosition min;
+    private final BlockPosition max; // Upper bound is exclusive
+
+    public CuboidRegion(Vec3 min, Vec3 max) {
+        this.min = BlockPosition.copyOf(min);
+        this.max = BlockPosition.copyOf(max);
+    }
+
+    @Override
+    public int size() {
+        final Vec3 d = max.minus(min);
+        return d.blockX() * d.blockY() * d.blockZ();
+    }
+
+    @Override
+    public boolean contains(Vec3 position) {
+        return min.isLessOrEqual(position) && max.isGreater(position);
+    }
+
+    @Override
+    public BlockPositionIterator iterator() {
+        return new Iterator();
+    }
+
+    class Iterator extends BlockPosition.MutableBlockPosition implements BlockPositionIterator {
+        private final int xMin, yMin;
+        private final int xMax, yMax, zMax;
+        private int xNext, yNext, zNext;
+        private boolean hasNext;
+
+        public Iterator() {
+            set(this.xNext = this.xMin = min.blockX(),
+                this.yNext = this.yMin = min.blockY(),
+                this.zNext = min.blockZ());
+            this.xMax = max.blockX();
+            this.yMax = max.blockY();
+            this.zMax = max.blockZ();
+            this.hasNext = blockX() < xMax && blockY() < yMax && blockZ() < zMax;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return hasNext;
+        }
+
+        @Override
+        public Vec3 next() {
+            if(!hasNext) {
+                throw new NoSuchElementException();
+            }
+
+            set(xNext, yNext, zNext);
+
+            if(++xNext >= xMax) {
+                xNext = xMin;
+                if(++yNext >= yMax) {
+                    yNext = yMin;
+                    if(++zNext >= zMax) {
+                        hasNext = false;
+                    }
+                }
+            }
+
+            return this;
+        }
+
+        @Override
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/FilteredBlockPositionIterator.java b/src/main/java/org/bukkit/craftbukkit/block/FilteredBlockPositionIterator.java
new file mode 100644
index 0000000..3e68fde
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/block/FilteredBlockPositionIterator.java
@@ -0,0 +1,26 @@
+package org.bukkit.craftbukkit.block;
+
+import java.util.Iterator;
+
+import com.google.common.base.Predicate;
+import org.bukkit.util.Vec3;
+
+public class FilteredBlockPositionIterator extends CachingBlockPositionIterator {
+
+    private final Iterator<Vec3> unfiltered;
+    private final Predicate<Vec3> filter;
+
+    public FilteredBlockPositionIterator(Iterator<Vec3> unfiltered, Predicate<Vec3> filter) {
+        this.unfiltered = unfiltered;
+        this.filter = filter;
+    }
+
+    @Override
+    protected Vec3 computeNext() {
+        while(unfiltered.hasNext()) {
+            final Vec3 p = unfiltered.next();
+            if(filter.apply(p)) return p;
+        }
+        return endOfData();
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/FilteredRegion.java b/src/main/java/org/bukkit/craftbukkit/block/FilteredRegion.java
new file mode 100644
index 0000000..47b44eb
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/block/FilteredRegion.java
@@ -0,0 +1,46 @@
+package org.bukkit.craftbukkit.block;
+
+import java.util.AbstractSet;
+import javax.annotation.Nullable;
+
+import com.google.common.base.Predicate;
+import org.bukkit.util.Vec3;
+import org.bukkit.block.BlockPositionIterator;
+import org.bukkit.block.BlockRegion;
+
+public abstract class FilteredRegion extends AbstractSet<Vec3> implements BlockRegion {
+
+    protected final BlockRegion unfiltered;
+    protected final Predicate<Vec3> predicate;
+
+    public FilteredRegion(BlockRegion unfiltered) {
+        this.unfiltered = unfiltered;
+        this.predicate = new Predicate<Vec3>() {
+            @Override
+            public boolean apply(@Nullable Vec3 position) {
+                return matches(position);
+            }
+        };
+    }
+
+    protected abstract boolean matches(Vec3 position);
+
+    @Override
+    public int size() {
+        int count = 0;
+        for(Vec3 p : unfiltered) {
+            if(matches(p)) count++;
+        }
+        return count;
+    }
+
+    @Override
+    public boolean contains(Vec3 position) {
+        return unfiltered.contains(position) && matches(position);
+    }
+
+    @Override
+    public BlockPositionIterator iterator() {
+        return new FilteredBlockPositionIterator(unfiltered.iterator(), predicate);
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/IdentityBlockTransform.java b/src/main/java/org/bukkit/craftbukkit/block/IdentityBlockTransform.java
new file mode 100644
index 0000000..b5bc787
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/block/IdentityBlockTransform.java
@@ -0,0 +1,70 @@
+package org.bukkit.craftbukkit.block;
+
+import org.bukkit.block.BlockFace;
+import org.bukkit.block.BlockOrientation;
+import org.bukkit.util.Vec3;
+import org.bukkit.block.BlockTransform;
+import org.bukkit.util.MutableVec3;
+
+public class IdentityBlockTransform implements BlockTransform {
+
+    private static final IdentityBlockTransform INSTANCE = new IdentityBlockTransform();
+    public static IdentityBlockTransform instance() { return INSTANCE; }
+
+    private IdentityBlockTransform() {}
+
+    @Override
+    public boolean isIdentity() {
+        return true;
+    }
+
+    @Override
+    public BlockTransform inverse() {
+        return this;
+    }
+
+    @Override
+    public Vec3 apply(Vec3 v) {
+        return v;
+    }
+
+    @Override
+    public void applyInPlace(MutableVec3 v) {
+    }
+
+    @Override
+    public BlockFace apply(BlockFace face) {
+        return face;
+    }
+
+    @Override
+    public BlockTransform apply(BlockTransform that) {
+        return that;
+    }
+
+    @Override
+    public BlockTransform andThen(BlockTransform that) {
+        return that;
+    }
+
+    @Override
+    public BlockOrientation orientation() {
+        return BlockOrientation.identity();
+    }
+
+    @Override
+    public int hashCode() {
+        return 0;
+    }
+
+    @Override
+    public boolean equals(Object that) {
+        return that instanceof BlockTransform &&
+               ((BlockTransform) that).isIdentity();
+    }
+
+    @Override
+    public String toString() {
+        return BlockTransform.class.getSimpleName() + "{identity}";
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/MaterialRegion.java b/src/main/java/org/bukkit/craftbukkit/block/MaterialRegion.java
new file mode 100644
index 0000000..6a70c27
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/block/MaterialRegion.java
@@ -0,0 +1,31 @@
+package org.bukkit.craftbukkit.block;
+
+import java.util.Set;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.IBlockData;
+import org.bukkit.World;
+import org.bukkit.util.Vec3;
+import org.bukkit.block.BlockRegion;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.material.MaterialData;
+
+public class MaterialRegion extends FilteredRegion {
+
+    private final net.minecraft.server.World world;
+    private final Set<IBlockData> materials;
+    private final boolean inverted;
+
+    public MaterialRegion(World world, BlockRegion unfiltered, Set<MaterialData> materials, boolean inverted) {
+        super(unfiltered);
+        this.world = ((CraftWorld) world).getHandle();
+        this.materials = CraftMagicNumbers.getBlockData(materials);
+        this.inverted = inverted;
+    }
+
+    @Override
+    protected boolean matches(Vec3 position) {
+        return inverted ^ materials.contains(world.getType(BlockPosition.of(position)));
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/TransformedRegion.java b/src/main/java/org/bukkit/craftbukkit/block/TransformedRegion.java
new file mode 100644
index 0000000..ace24e5
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/block/TransformedRegion.java
@@ -0,0 +1,68 @@
+package org.bukkit.craftbukkit.block;
+
+import java.util.AbstractSet;
+
+import net.minecraft.server.BlockPosition;
+import org.bukkit.util.Vec3;
+import org.bukkit.block.BlockPositionIterator;
+import org.bukkit.block.BlockRegion;
+import org.bukkit.block.BlockTransform;
+
+public class TransformedRegion extends AbstractSet<Vec3> implements BlockRegion {
+
+    private final BlockRegion region;
+    private final BlockTransform transform, inverse;
+
+    public static BlockRegion of(BlockRegion region, BlockTransform transform) {
+        if(transform.isIdentity()) {
+            return region;
+        } else if(region instanceof TransformedRegion) {
+            final TransformedRegion transformedRegion = (TransformedRegion) region;
+            return of(transformedRegion.region,
+                      transformedRegion.transform.andThen(transform));
+        } else {
+            return new TransformedRegion(region, transform);
+        }
+    }
+
+    private TransformedRegion(BlockRegion region, BlockTransform transform) {
+        this.region = region;
+        this.transform = transform;
+        this.inverse = transform.inverse();
+    }
+
+    @Override
+    public int size() {
+        return region.size();
+    }
+
+    @Override
+    public boolean contains(Vec3 position) {
+        return region.contains(inverse.apply(position));
+    }
+
+    @Override
+    public BlockPositionIterator iterator() {
+        return new Iterator();
+    }
+
+    class Iterator extends BlockPosition.MutableBlockPosition implements BlockPositionIterator {
+        private final BlockPositionIterator iter = region.iterator();
+
+        @Override
+        public boolean hasNext() {
+            return iter.hasNext();
+        }
+
+        @Override
+        public Vec3 next() {
+            set(transform.apply(iter.next()));
+            return this;
+        }
+
+        @Override
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/material/CraftBlockOrienter.java b/src/main/java/org/bukkit/craftbukkit/material/CraftBlockOrienter.java
new file mode 100644
index 0000000..e93c447
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/material/CraftBlockOrienter.java
@@ -0,0 +1,91 @@
+package org.bukkit.craftbukkit.material;
+
+import net.minecraft.server.EnumBlockMirror;
+import net.minecraft.server.EnumBlockRotation;
+import net.minecraft.server.IBlockData;
+import org.bukkit.block.BlockOrientation;
+import org.bukkit.block.BlockReflection;
+import org.bukkit.block.BlockRotation;
+import org.bukkit.block.BlockTransform;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.material.MaterialData;
+import org.bukkit.material.BlockOrienter;
+
+public class CraftBlockOrienter implements BlockOrienter {
+
+    private static final CraftBlockOrienter INSTANCE = new CraftBlockOrienter();
+    public static CraftBlockOrienter instance() { return INSTANCE; }
+
+    public static BlockReflection toBukkit(EnumBlockMirror nms) {
+        switch(nms) {
+            case NONE: return BlockReflection.NONE;
+            case LEFT_RIGHT: return BlockReflection.LEFT_RIGHT;
+            case FRONT_BACK: return BlockReflection.FRONT_BACK;
+        }
+        throw new IllegalStateException();
+    }
+
+    public static EnumBlockMirror toNms(BlockReflection bukkit) {
+        switch(bukkit) {
+            case NONE: return EnumBlockMirror.NONE;
+            case LEFT_RIGHT: return EnumBlockMirror.LEFT_RIGHT;
+            case FRONT_BACK: return EnumBlockMirror.FRONT_BACK;
+        }
+        throw new IllegalStateException();
+    }
+
+    public static BlockRotation toBukkit(EnumBlockRotation nms) {
+        switch(nms) {
+            case NONE: return BlockRotation.NONE;
+            case CLOCKWISE_90: return BlockRotation.CLOCKWISE_90;
+            case CLOCKWISE_180: return BlockRotation.CLOCKWISE_180;
+            case COUNTERCLOCKWISE_90: return BlockRotation.COUNTERCLOCKWISE_90;
+        }
+        throw new IllegalStateException();
+    }
+
+    public static EnumBlockRotation toNms(BlockRotation nms) {
+        switch(nms) {
+            case NONE: return EnumBlockRotation.NONE;
+            case CLOCKWISE_90: return EnumBlockRotation.CLOCKWISE_90;
+            case CLOCKWISE_180: return EnumBlockRotation.CLOCKWISE_180;
+            case COUNTERCLOCKWISE_90: return EnumBlockRotation.COUNTERCLOCKWISE_90;
+        }
+        throw new IllegalStateException();
+    }
+
+    public IBlockData reorient(IBlockData data, BlockOrientation orientation) {
+        if(orientation.isIdentity()) return data;
+
+        // Mojang applies reflection first, so we do too
+        data = data.a(toNms(orientation.reflection()));
+        data = data.a(toNms(orientation.rotation()));
+        return data;
+    }
+
+    @Override
+    public MaterialData reorient(MaterialData material, BlockOrientation orientation) {
+        if(orientation.isIdentity()) return material;
+
+        return CraftMagicNumbers.nmsBlockStateToMaterialData(
+            reorient(CraftMagicNumbers.getBlockData(material), orientation)
+        );
+    }
+
+    @Override
+    public MaterialData reorient(MaterialData material, BlockTransform transform) {
+        return reorient(material, transform.orientation());
+    }
+
+    @Override
+    public MaterialData reflect(MaterialData material, BlockReflection reflection) {
+        if(reflection == BlockReflection.NONE) return material;
+        return reorient(material, BlockOrientation.of(reflection));
+    }
+
+    @Override
+    public MaterialData rotate(MaterialData material, BlockRotation rotation) {
+        if(rotation == BlockRotation.NONE) return material;
+        return reorient(material, BlockOrientation.of(rotation));
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index b3ecbb7..a104746 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -1,5 +1,6 @@
 package org.bukkit.craftbukkit.util;
 
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 import java.util.ArrayList;
 import java.util.Iterator;
@@ -101,6 +102,23 @@ public final class CraftMagicNumbers implements UnsafeValues {
         return getBlock(material.getItemType()).fromLegacyData(material.getData());
     }
 
+    public static Set<IBlockData> getBlockData(Set<MaterialData> materials) {
+        ImmutableSet.Builder<IBlockData> nms = ImmutableSet.builder();
+        for(MaterialData bukkit : materials) {
+            nms.add(getBlockData(bukkit));
+        }
+        return nms.build();
+    }
+
+    public static MaterialData nmsBlockStateToMaterialData(IBlockData data) {
+        final Block block = data.getBlock();
+        final int legacyId = getId(block);
+        final byte legacyData = (byte) block.toLegacyData(data);
+        final Material material = Material.getMaterial(legacyId);
+        return material == null ? new MaterialData(legacyId, legacyData)
+                                : material.getNewData(legacyData);
+    }
+
     @Override
     public Material getMaterialFromInternalName(String name) {
         return getMaterial((Item) Item.REGISTRY.get(new MinecraftKey(name)));
diff --git a/src/test/java/org/bukkit/block/BlockOrienterTest.java b/src/test/java/org/bukkit/block/BlockOrienterTest.java
new file mode 100644
index 0000000..7471757
--- /dev/null
+++ b/src/test/java/org/bukkit/block/BlockOrienterTest.java
@@ -0,0 +1,55 @@
+package org.bukkit.block;
+
+import org.bukkit.Bukkit;
+import org.bukkit.Material;
+import org.bukkit.material.Directional;
+import org.bukkit.material.Lever;
+import org.bukkit.material.MaterialData;
+import org.bukkit.support.BukkitRuntimeTest;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class BlockOrienterTest extends BukkitRuntimeTest {
+
+    void normalize(MaterialData data) {
+        final Directional directional = (Directional) data;
+        directional.setFacingDirection(directional.getFacing());
+    }
+
+    void test(MaterialData material, BlockOrientation orientation) {
+        normalize(material);
+
+        // Transform with the BlockOrienter
+        final MaterialData actual = Bukkit.blockOrienter().reorient(material, orientation);
+
+        // Transform through the Directional interface
+        final MaterialData expected = material.clone();
+        if(expected instanceof Lever) {
+            final Lever lever = (Lever) expected;
+            lever.setFacingDirection(orientation.apply(lever.getFacing()),
+                                     orientation.apply(lever.getAxis()));
+        } else {
+            final Directional directional = (Directional) expected;
+            final BlockFace facing = directional.getFacing();
+            directional.setFacingDirection(orientation.apply(facing));
+        }
+
+        // Assert identical results
+        assertEquals("material=" + material.getItemType() + " data=" + material + " orientation=" + orientation,
+                     expected, actual);
+    }
+
+    @Test
+    public void reorientDirectionalBlocks() throws Exception {
+        for(Material type : Material.values()) {
+            if(Directional.class.isAssignableFrom(type.getData())) {
+                final MaterialData material = type.getNewData((byte) 0);
+                for(BlockRotation rotation : BlockRotation.values()) {
+                    test(material, BlockOrientation.of(BlockReflection.NONE, rotation));
+                    test(material, BlockOrientation.of(BlockReflection.X, rotation));
+                }
+            }
+        }
+    }
+}
diff --git a/src/test/java/org/bukkit/block/BlockTransformTest.java b/src/test/java/org/bukkit/block/BlockTransformTest.java
new file mode 100644
index 0000000..e7dd101
--- /dev/null
+++ b/src/test/java/org/bukkit/block/BlockTransformTest.java
@@ -0,0 +1,235 @@
+package org.bukkit.block;
+
+import java.util.Random;
+
+import net.minecraft.server.BlockPosition;
+import org.bukkit.Bukkit;
+import org.bukkit.util.Axis;
+import org.bukkit.util.Vec3;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class BlockTransformTest {
+
+    BlockTransformFactory T;
+    Random random = new Random();
+
+    @Before
+    public void setUp() throws Exception {
+        T = Bukkit.blockTransforms();
+    }
+
+    Vec3 rand() {
+        return new BlockPosition(random.nextInt(2000) - 1000,
+                                 random.nextInt(2000) - 1000,
+                                 random.nextInt(2000) - 1000);
+    }
+
+    @Test
+    public void identity() throws Exception {
+        Vec3 p = rand();
+        assertEquals(p, T.identity().apply(p));
+    }
+
+    @Test
+    public void inverseIdentity() throws Exception {
+        Vec3 p = rand();
+        assertEquals(T.identity(), T.identity().inverse());
+        assertEquals(p, T.identity().inverse().apply(p));
+    }
+
+    @Test
+    public void compoundIdentity() throws Exception {
+        Vec3 p = rand();
+        assertEquals(T.identity(), T.identity().andThen(T.identity()));
+        assertEquals(T.identity(), T.identity().apply(T.identity()));
+        assertEquals(p, T.identity().andThen(T.identity()).apply(p));
+        assertEquals(p, T.identity().apply(T.identity()).apply(p));
+    }
+
+    @Test
+    public void translation() throws Exception {
+        Vec3 p = rand();
+        Vec3 t = rand();
+        assertEquals(p.plus(t),
+                     T.translation(t).apply(p));
+    }
+
+    @Test
+    public void inverseTranslation() throws Exception {
+        Vec3 p = rand();
+        Vec3 t = rand();
+        assertEquals(p.plus(t.negate()),
+                     T.translation(t).inverse().apply(p));
+    }
+
+    @Test
+    public void compoundTranslation() throws Exception {
+        Vec3 p = rand();
+        Vec3 t1 = rand();
+        Vec3 t2 = rand();
+
+        assertEquals(T.translation(t1.plus(t2)),
+                     T.translation(t1).andThen(T.translation(t2)));
+
+        assertEquals(p.plus(t1).plus(t2),
+                     T.translation(t1).andThen(T.translation(t2)).apply(p));
+
+        assertEquals(T.translation(t1.plus(t2)),
+                     T.translation(t1).apply(T.translation(t2)));
+    }
+
+    @Test
+    public void rotationCW() throws Exception {
+        Vec3 p = rand();
+        Vec3 q;
+
+        q = T.rotationCW(0).apply(p);
+        assertEquals(p, q);
+
+        q = T.rotationCW(1).apply(p);
+        assertEquals(p.blockX(), -q.blockZ());
+        assertEquals(p.blockY(), q.blockY());
+        assertEquals(p.blockZ(), q.blockX());
+
+        q = T.rotationCW(2).apply(p);
+        assertEquals(p.blockX(), -q.blockX());
+        assertEquals(p.blockY(), q.blockY());
+        assertEquals(p.blockZ(), -q.blockZ());
+
+        q = T.rotationCW(3).apply(p);
+        assertEquals(p.blockX(), q.blockZ());
+        assertEquals(p.blockY(), q.blockY());
+        assertEquals(p.blockZ(), -q.blockX());
+    }
+
+    @Test
+    public void rotationCCW() throws Exception {
+        Vec3 p = rand();
+
+        assertEquals(p, T.rotationCCW(0).apply(p));
+        assertEquals(T.rotationCW(3).apply(p), T.rotationCCW(1).apply(p));
+        assertEquals(T.rotationCW(2).apply(p), T.rotationCCW(2).apply(p));
+        assertEquals(T.rotationCW(1).apply(p), T.rotationCCW(3).apply(p));
+    }
+
+    @Test
+    public void negativeRotation() throws Exception {
+        Vec3 p = rand();
+
+        assertEquals(T.rotationCW(1).apply(p),
+                     T.rotationCW(1 - 4).apply(p));
+
+        assertEquals(T.rotationCCW(1).apply(p),
+                     T.rotationCCW(1 - 4).apply(p));
+    }
+
+    @Test
+    public void wrappedRotation() throws Exception {
+        Vec3 p = rand();
+
+        assertEquals(T.rotationCW(1).apply(p),
+                     T.rotationCW(1 + 4).apply(p));
+
+        assertEquals(T.rotationCCW(1).apply(p),
+                     T.rotationCCW(1 + 4).apply(p));
+    }
+
+    @Test
+    public void inverseRotation() throws Exception {
+        Vec3 p = rand();
+
+        assertEquals(T.rotationCCW(1).apply(p),
+                     T.rotationCW(1).inverse().apply(p));
+    }
+
+    @Test
+    public void compoundRotation() throws Exception {
+        Vec3 p = rand();
+
+        assertEquals(T.rotationCW(2).apply(p),
+                     T.rotationCW(1).andThen(T.rotationCW(1)).apply(p));
+
+        assertEquals(T.rotationCW(2).apply(p),
+                     T.rotationCW(1).apply(T.rotationCW(1)).apply(p));
+    }
+
+    @Test
+    public void compoundTransform() throws Exception {
+        Vec3 p = rand();
+        BlockTransform t = T.translation(rand());
+        BlockTransform r = T.rotationCW(random.nextInt(4));
+
+        assertEquals(t.apply(r.apply(p)),
+                     t.apply(r).apply(p));
+
+        assertEquals(r.apply(t.apply(p)),
+                     r.apply(t).apply(p));
+
+        assertEquals(r.apply(t.apply(p)),
+                     t.andThen(r).apply(p));
+
+        assertEquals(t.apply(r.apply(p)),
+                     r.andThen(t).apply(p));
+    }
+
+    @Test
+    public void manyTransforms() throws Exception {
+        Vec3 p = rand();
+        Vec3 q = p;
+        BlockTransform a = T.identity();
+        BlockTransform b = T.identity();
+        BlockTransform z;
+
+        for(int i = 0; i < 10; i++) {
+            z = i % 2 == 0 ? T.translation(rand())
+                           : T.rotationCW(random.nextInt(4));
+
+            q = z.apply(q);
+            a = z.apply(a);
+            b = b.andThen(z);
+
+            assertEquals(q, a.apply(p));
+            assertEquals(q, b.apply(p));
+        }
+    }
+
+    @Test
+    public void detectIdentityOrientation() throws Exception {
+        assertEquals(BlockOrientation.identity(), T.identity().orientation());
+    }
+
+    @Test
+    public void detectReflection() throws Exception {
+        assertEquals(BlockOrientation.of(BlockReflection.X),
+                     T.reflection(Axis.X).orientation());
+
+        assertEquals(BlockOrientation.of(BlockReflection.X, BlockRotation.CLOCKWISE_180),
+                     T.reflection(Axis.Z).orientation());
+
+        assertEquals(BlockOrientation.of(BlockReflection.NONE, BlockRotation.CLOCKWISE_180),
+                     T.reflection(Axis.X).andThen(T.reflection(Axis.Z)).orientation());
+    }
+
+    @Test
+    public void detectRotation() throws Exception {
+        assertEquals(BlockOrientation.of(BlockRotation.CLOCKWISE_90), T.rotationCW(1).orientation());
+        assertEquals(BlockOrientation.of(BlockRotation.CLOCKWISE_180), T.rotationCW(2).orientation());
+        assertEquals(BlockOrientation.of(BlockRotation.CLOCKWISE_270), T.rotationCW(3).orientation());
+
+        assertEquals(BlockOrientation.of(BlockRotation.COUNTERCLOCKWISE_90), T.rotationCCW(1).orientation());
+        assertEquals(BlockOrientation.of(BlockRotation.COUNTERCLOCKWISE_180), T.rotationCCW(2).orientation());
+        assertEquals(BlockOrientation.of(BlockRotation.COUNTERCLOCKWISE_270), T.rotationCCW(3).orientation());
+    }
+
+    @Test
+    public void detectReflectionAndRotation() throws Exception {
+        assertEquals(BlockOrientation.of(BlockReflection.X, BlockRotation.CLOCKWISE_90),
+                     T.reflection(Axis.X).andThen(T.rotationCW(1)).orientation());
+
+        assertEquals(BlockOrientation.of(BlockReflection.X, BlockRotation.COUNTERCLOCKWISE_90),
+                     T.reflection(Axis.Z).andThen(T.rotationCW(1)).orientation());
+    }
+}
diff --git a/src/test/java/org/bukkit/support/BukkitRuntimeTest.java b/src/test/java/org/bukkit/support/BukkitRuntimeTest.java
new file mode 100644
index 0000000..1703f40
--- /dev/null
+++ b/src/test/java/org/bukkit/support/BukkitRuntimeTest.java
@@ -0,0 +1,26 @@
+package org.bukkit.support;
+
+import org.bukkit.Bukkit;
+import org.bukkit.CraftBukkitRuntime;
+import org.junit.After;
+import org.junit.Before;
+
+public class BukkitRuntimeTest {
+
+    private boolean setRuntime;
+
+    @Before
+    public void setUp() throws Exception {
+        setRuntime = Bukkit.getRuntime() == null;
+        if(setRuntime) {
+            CraftBukkitRuntime.load();
+        }
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        if(setRuntime) {
+            Bukkit.setRuntime(null);
+        }
+    }
+}
diff --git a/src/test/java/org/bukkit/util/Vec3Test.java b/src/test/java/org/bukkit/util/Vec3Test.java
new file mode 100644
index 0000000..29d1579
--- /dev/null
+++ b/src/test/java/org/bukkit/util/Vec3Test.java
@@ -0,0 +1,38 @@
+package org.bukkit.util;
+
+import net.minecraft.server.BlockPosition;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class Vec3Test {
+
+    void assertMutuallyEqual(Object a, Object b) {
+        assertTrue(a + " should equal " + b, a.equals(b));
+        assertTrue(b + " should equal " + a, b.equals(a));
+
+        assertEquals(a + " and " + b + " should have identical hashCodes",
+                     a.hashCode(), b.hashCode());
+    }
+
+    void assertMutuallyUnequal(Object a, Object b) {
+        assertFalse(a + " should not equal " + b, a.equals(b));
+        assertFalse(b + " should not equal " + a, b.equals(a));
+    }
+
+    @Test
+    public void coarseEquality() throws Exception {
+        assertMutuallyEqual(new BlockPosition(1, 2, 3), new BlockVector(1, 2, 3));
+        assertMutuallyEqual(new BlockPosition(1, 2, 3), new BlockVector(1.5, 2.5, 3.5));
+    }
+
+    @Test
+    public void coarseInequality() throws Exception {
+        // Coarse vectors with different values
+        assertMutuallyUnequal(new BlockPosition(1, 2, 3), new BlockVector(4, 5, 6));
+
+        // Mix coarse and fine vectors
+        assertMutuallyUnequal(new BlockPosition(1, 2, 3), new Vector(1, 2, 3));
+        assertMutuallyUnequal(new BlockVector(1, 2, 3), new Vector(1, 2, 3));
+    }
+}
-- 
1.9.0

